##1.关于分布式系统的认知 
###1.什么是分布式系统? 
	分布式系统是一种通常由多组节点组成的分散的系统，这些不同组的节点一般情况下只能作为整个系统的一部分存在，各组节点之间互相按照系统设定的角色通过通信交换信息，并通过一定的共识策略达到状态一致，从而对外保持一致状态并屏蔽内部关系对外表现为单一系统。
###2.分布式系统解决什么问题? 
	2.1 '弹性伸缩':对比单机或单一大型机,扩缩容一个节点相比更换单点服务的机器更容易,也容易实现graceful操作。 
	2.2 '高性能':对比只增加单机能力的情况下性能可以在相当大的范围内线性增长。 
	2.3 '安全性':主要体现的是隔离带来的安全性，如物理距离上的隔离，系统解耦合的隔离。 
	2.4 '高可靠性':对比单点整个系统的稳定性更高一点，相对容易通过一定的策略保持整个系统尽可能一直对外提供服务而不受单点掉线影响。 
	2.5 '给予系统更多的灵活性':其实分布式从某种程度上理解，解决问题的思路也是通过增加中间层来解决的，分布式就是在应用层和资源层增加了一个适配层解决的，对应用层来说我需要的是把我手头上这些物理资源尽可能的为我的业务提供更高质量(性能，稳定性，安全性等等)的服务，但是业务有时候无法将自己变成无状态的去适配这些零散的物理资源，(这里说的业务不包含可以自己实现管理资源的能力，就是纯粹的业务逻辑。)所以就可以通过增加一个分布式的资源管理工具，对底层资源进行屏蔽，对业务表现为一个单一系统提供简单API服务，而内部可以通过不同的技术手段和策略实现高度自治，性能，容灾，可用性，同步等复杂性质做闭环。 
###3.为什么要用分布式系统? 
	也不是所有的服务都徐还要分布式系统，那需要分布式系统的服务一般都有一个特点:有状态。如果一个业务是无状态的，那么可以理论上无限制的通过copy相同能力的节点实现集群来提供高性能的服务，前边挂个反向代理服务就好了，那接着看有状态的服务，一定需要分布式系统吗，其实也不一定，能用分布式系统解决的问题并不是只有唯一解，例如也可以通过大型机实现，或者业务改造或者两者都有，例如传统的关系型数据库，先是单点，然后是扩大单个节点的能力，然后是业务改造，最后成本实在太大或者不能满足业务增长，只能分布式。 
###4.分布式系统带来的问题是什么，如何处理? 
	分布式本身主要的技术手段是:replication，而replication必然存在一个时间段内的节点状态不一致情况，因为即使是信号以光速传播，它也需要时间，例如受限于物理距离的多机房节点同步，感知的时间延迟在高负载下也是不可忽略的，而实际上更多的是受到分布式共识策略和网络的不确定性影响，共识策略需要满足一定条件才能让所有节点达成一致，而让所有节点达成一致的难度会随着需要同步的节点的额规模的增加而增大，因为需要的时间会变长，同时失败的概率会增加，网络的不确定性也会增加。而这些问题的处理不能一概而论，而是要根据业务的场景适配不同的共识策略，这个共识策略通过影响状态同步的强弱程度而在可用性，一致性，分区容忍性之间做权衡，所以也会出现CAP,BASE,XA这些讨论共识的理论。不幸的是，现实实现中收到的掣肘的因素会更多，一般人类的共识都会基于时间这个单向轴做排序，而在全局范围内想让位于不同空间的两个点做到足够精确的相等需要付出可观的代价，所以，并没有银弹方案，适合业务的才是最好的。 
	
	
##2.关于分布式核心技术的认知
    分布式核心技术可以简化为都是基于replication的，只是不同的业务场景下，对replication的策略以及应对分布式问题的权衡不同。
    我们这里叫做P/B复制，就是primary/backup。 P/B复制无论是同步模式还是异步模式，都无法解决下边的情况：如果resp-2失败了，对于client来说它永远无法通过P/B模型而不借助其它措施准确的知道数据是否更新成功:
    client===write-1===>primary===write-2==>slave
                                           ||
           <=====resp-2====<==resp-1=======||
    这种情况其实也不是无解，通过其它手段还是很好解决的，只是需要额外的做状态记录，甚至是人工干预纠正。
   
##3.关于partition-tolerant的认知
    在理论上，可以有一个能容忍任何失败情况的拜占庭式的恶意操作，但是这种算法成本太高，一般不考虑。
    在partition fault中，网络失败和节点失败对于系统的其它节点来说效果是一样的。
    因为在出现network partition而不能解决divergence的时候，必须要保证整个系统对外只有一个分区保持活动状态，这个也是为什么现在的一些CP算法需要支持majority vote的原因。
    在分区容忍上一般由两种构建系统的方式。1. 所有节点保持相同的角色 2.节点担任不同的角色。 partition选择后者。这种模式能保持高效的决策，容易提高决策效率。而且并不妨碍系统从leader/master中恢复。
    在paxos这类算法中，往往使用logical clock，尽可能唯一选出一个有效的leader节点，其它的失败掉。
    